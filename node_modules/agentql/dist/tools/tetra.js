"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserProfile = exports.UserAgentPreset = exports.BrowserSession = void 0;
exports.createBrowserSession = createBrowserSession;
const axios_1 = require("axios");
const api_constants_1 = require("../core/api-constants");
const errors_1 = require("../core/errors");
const logger_1 = require("../core/logger");
const utils_1 = require("../core/utils");
/**
 * User Agent presets for different operating systems.
 * By selecting specific preset underlying remote browser will mimic user agent of the selected operating system modifying HTTP headers, navigator object and more.
 */
var UserAgentPreset;
(function (UserAgentPreset) {
    UserAgentPreset["WINDOWS"] = "windows";
    UserAgentPreset["MACOS"] = "macos";
    UserAgentPreset["LINUX"] = "linux";
})(UserAgentPreset || (exports.UserAgentPreset = UserAgentPreset = {}));
/**
 * Browser profile presets for different use cases.
 * - LIGHT: Basic browser profile with standard configurations
 * - STEALTH: Enhanced profile with advanced stealth measures
 */
var BrowserProfile;
(function (BrowserProfile) {
    BrowserProfile["LIGHT"] = "light";
    BrowserProfile["STEALTH"] = "stealth";
})(BrowserProfile || (exports.BrowserProfile = BrowserProfile = {}));
/**
 * Validate proxy configuration according to business rules.
 */
function validateProxyConfig(proxy) {
    if (!proxy) {
        return;
    }
    if (!proxy.type) {
        throw new Error("Proxy configuration must include 'type' field");
    }
    if (proxy.type === 'tetra') {
        // Tetra proxy should not have url, username, or password
        const tetraProxy = proxy;
        const invalidFields = [];
        if (tetraProxy.url)
            invalidFields.push('url');
        if (tetraProxy.username)
            invalidFields.push('username');
        if (tetraProxy.password)
            invalidFields.push('password');
        if (invalidFields.length > 0) {
            throw new Error(`Tetra proxy type cannot have the following fields: ${invalidFields.join(', ')}. ` +
                "Only 'type' and 'countryCode' are allowed for Tetra proxy.");
        }
    }
    else if (proxy.type === 'custom') {
        const customProxy = proxy;
        // Custom proxy must have url
        if (!customProxy.url) {
            throw new Error("Custom proxy type requires 'url' field");
        }
        // Custom proxy should not have countryCode
        if (proxy.countryCode) {
            throw new Error("Custom proxy type cannot have 'countryCode' field. " +
                'Country code is only supported for Tetra proxy.');
        }
    }
    else {
        throw new Error(`Invalid proxy type: '${proxy.type}'. Must be either 'tetra' or 'custom'`);
    }
}
/**
 * Core implementation for creating a browser session.
 */
function createBrowserSessionCore() {
    return __awaiter(this, arguments, void 0, function* (options = {}) {
        var _a;
        const profile = options.profile;
        const uaPreset = options.uaPreset;
        if (profile === BrowserProfile.STEALTH && uaPreset) {
            throw new Error('Invalid configuration: uaPreset cannot be specified with STEALTH profile. ' +
                'STEALTH profile automatically manages user agents for optimal anti-detection.');
        }
        validateProxyConfig(options.proxy);
        const apiKey = (0, utils_1.getApiKey)();
        const url = `${api_constants_1.SERVICE_URL}${api_constants_1.BROWSER_SESSIONS_ENDPOINT}`;
        const headers = { 'X-API-Key': apiKey };
        // Prepare request body
        const body = {};
        if (uaPreset) {
            body.browser_ua_preset = uaPreset;
        }
        if (profile) {
            body.browser_profile = profile;
        }
        if (options.inactivityTimeoutSeconds !== undefined) {
            body.inactivity_timeout_seconds = options.inactivityTimeoutSeconds;
        }
        if (options.proxy) {
            // Convert camelCase to snake_case for API
            const proxy = { type: options.proxy.type };
            if (options.proxy.type === 'tetra' && options.proxy.countryCode) {
                proxy.country_code = options.proxy.countryCode;
            }
            else if (options.proxy.type === 'custom') {
                const customProxy = options.proxy;
                proxy.url = customProxy.url;
                if (customProxy.username)
                    proxy.username = customProxy.username;
                if (customProxy.password)
                    proxy.password = customProxy.password;
            }
            body.proxy = proxy;
        }
        try {
            const response = yield axios_1.default.post(url, body, { headers });
            const sessionData = response.data;
            const browserSession = new BrowserSession(sessionData);
            logger_1.logger.info(`Successfully allocated browser session: ${browserSession.cdpUrl}`);
            return browserSession;
        }
        catch (error) {
            if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 401) {
                throw new errors_1.APIKeyError('Invalid or expired API key provided.');
            }
            logger_1.logger.error(`Failed to allocate browser session: ${error.message}`);
            throw new Error(`Failed to create browser session: ${error.message}`);
        }
    });
}
/**
 * Represents an allocated browser session with CDP connection details.
 */
class BrowserSession {
    /**
     * Initialize BrowserSession with session data from the API.
     *
     * @param sessionData - Raw session data returned from the browser allocation API
     * @throws Error if required fields are missing from sessionData
     */
    constructor(sessionData) {
        const requiredFields = ['cdp_url', 'base_url'];
        const invalidFields = requiredFields.reduce((acc, field) => {
            if (!(field in sessionData))
                acc.missing.push(field);
            else if (!sessionData[field])
                acc.empty.push(field);
            return acc;
        }, { missing: [], empty: [] });
        if (invalidFields.missing.length > 0) {
            throw new Error(`Missing required fields in session_data: ${invalidFields.missing.join(', ')}`);
        }
        if (invalidFields.empty.length > 0) {
            throw new Error(`Required fields cannot be empty: ${invalidFields.empty.join(', ')}`);
        }
        this._cdpUrl = sessionData['cdp_url'];
        this._baseUrl = sessionData['base_url'];
    }
    /**
     * Get the Chrome DevTools Protocol URL for connecting to the browser.
     *
     * @returns The CDP URL for browser connection
     */
    get cdpUrl() {
        return this._cdpUrl;
    }
    /**
     * Get the page streaming URL for a specific page number.
     *
     * @param pageNum - The page number to get the streaming URL for
     * @returns The streaming URL for the specified page
     */
    getPageStreamingUrl(pageNum) {
        if (pageNum < 0) {
            throw new Error('Page number must be non-negative');
        }
        return `${this._baseUrl}/stream/${pageNum}`;
    }
}
exports.BrowserSession = BrowserSession;
function createBrowserSession(arg) {
    return __awaiter(this, void 0, void 0, function* () {
        const options = typeof arg === 'string' ? { uaPreset: arg } : arg !== null && arg !== void 0 ? arg : {};
        return createBrowserSessionCore(options);
    });
}
